# frozen_string_literal: true

require 'fileutils'
require 'json'
require 'asciidoctor'
require 'yaml'
require 'date'

# Load DocOps Lab development tooling
require 'docopslab/dev'

# Configuration
JEKYLL_CONFIG = YAML.load_file('_config.yml')
DEPLOY_BRANCH = 'gh-pages'
BUILD_DIR = JEKYLL_CONFIG['destination'] || '_site'
SLIDES_DIR = 'slides'
PROJECTS_DATA = YAML.safe_load_file('_data/docops-lab-projects.yml', permitted_classes: [Date])

desc 'Extract AsciiDoc attributes for single-sourcing'
task :extract_readme_attrs do
  puts 'ğŸ” Extracting AsciiDoc attributes from README.adoc...'
  attrs = {}
  doc = Asciidoctor.load_file('README.adoc', safe: :safe)
  sensitive_keys = %w[user-home docfile docdir]
  sensitive_keys.each { |key| doc.attributes.delete(key) if doc.attributes.key?(key) }
  doc.attributes.each do |key, value|
    if key.end_with?('-desc') && value && !value.empty?
      attrs[key.sub('-desc', '')] = value
    else
      attrs[key] = value
    end
  end
  FileUtils.mkdir_p('_data/built')
  File.write('_data/built/attrs.yml', attrs.to_yaml)
  puts 'âœ… Extracted to _data/built/attrs.yml'
end

desc 'Validate projects YAML file'
task :validate_projects do
  require_relative 'scripts/validate-projects-yaml'
  
  file_path = '_data/docops-lab-projects.yml'
  puts "ğŸ” Validating #{file_path}..."
  validator = ProjectsYAMLValidator.new(file_path)
  
  unless validator.validate
    exit 1
  end
end

# Utility: Convert arbitrary HTML to Markdown using our ReverseMarkdown extensions
namespace :util do
  desc 'Convert HTML to Markdown (args: source, dest). Uses MarkDownGrade and writes to .agent by default.'
  task :html_to_md, [:source, :dest] do |_, args|
    require 'nokogiri'
    require_relative 'scripts/mark_down_grade'

    MarkDownGrade.bootstrap!

    source = args[:source] || File.join(BUILD_DIR, 'metablog', 'tech-blogging-in-asciidoc', 'index.html')
    dest   = args[:dest]   || File.join('.agent', 'converted', 'metablog-tech-blogging-in-asciidoc.md')

    unless File.exist?(source)
      puts "ğŸ”¨ Building site to generate #{source}..."
      Rake::Task['build_site'].invoke
    end

    unless File.exist?(source)
      puts "âŒ Source HTML not found: #{source}"
      next
    end

    html = File.read(source)
    doc = Nokogiri::HTML(html)

    # Prefer specific content wrappers to avoid bringing site chrome
    container = doc.at_css('div.document-body') ||
                doc.at_css('div.post-content.metablog') ||
                doc.at_css('div.post-content') ||
                doc.at_css('article.blog-post .post-content') ||
                doc.at_css('article.blog-post') ||
                doc.at_css('article') ||
                doc.at_css('main') ||
                doc.at_css('body')

    if container.nil?
      puts "âŒ Could not find content container in #{source}"
      next
    end

    # Remove non-content bits inside the container
    container.css(
      'script,
       style,
       nav,
       .post-navigation,
       .back-to-metablog,
       .back-to-blog,
       .metablog-banner,
       footer').remove

    markdown = MarkDownGrade.convert(container.inner_html, github_flavored: true)

    FileUtils.mkdir_p(File.dirname(dest))
    File.write(dest, markdown)
    puts "âœ… Wrote #{dest}"
  end
end

desc 'Generate project pages from project data (AsciiDoc)'
task :generate_project_pages do
  puts 'ğŸ“„ Generating project pages (.adoc)...'

  # Create _projects directory if it doesn't exist
  FileUtils.mkdir_p('_projects')

  # Load project data
  projects_data = PROJECTS_DATA
  projects = projects_data['projects']
  # select only projects with page or star (not nil)
  paged_projects = projects.select { |p| p['page'] || p['star'] }

  # Clear existing project pages
  Dir.glob('_projects/*.adoc').each { |f| File.delete(f) }

  paged_projects.each do |project|
    slug = project['slug'] || project['name']&.downcase&.gsub(/[^a-z0-9\-_]/, '-')
    next unless slug

    filename = "_projects/#{slug}.adoc"

    # Generate frontmatter
    project_name = project['name'] || slug.split('-').map(&:capitalize).join(' ')
    frontmatter = {
      'layout' => 'projects',
      'title' => project_name,
      'slug' => slug,
      'type' => 'profile',
      'generated' => true,
      'generation_date' => Time.now.strftime('%Y-%m-%d %H:%M:%S'),
      'liquid' => true
    }

    # Add optional fields if present
    frontmatter['category'] = project['type'] if project['type']
    frontmatter['status'] = project['done'] ? 'live' : 'development' if project.key?('live')
    frontmatter['tags'] = project['tags'] if project['tags']

    # Create the file content
    content = "#{frontmatter.to_yaml}---\n\n"
    content += "// This page is auto-generated by rake generate_project_pages\n"
    content += "// Source data: _data/docops-lab-projects.yml\n\n"
    content += "++++\n"
    content += "{% include project-page.html slug=page.slug %}\n"
    content += "++++\n"

    # Write the file
    File.write(filename, content)
    puts "  âœ“ Generated #{filename}"
  end

  puts "âœ… Generated #{paged_projects.count} project pages (.adoc)"
end

desc 'Generate metadata master files for projects'
task :generate_metadata do
  puts 'ğŸ“Š Generating project metadata...'

  # Load project data
  projects_data = PROJECTS_DATA
  projects = projects_data['projects']

  # Collect unique tags and tech and make a types dictionary
  tags = projects.flat_map { |p| p['tags'] || [] }.uniq.sort
  tech = projects.flat_map { |p| p['tech'] || [] }.uniq.sort
  # generate type parameters from $meta['types'] based on text: defaulting to head:
  # should yield like:
  # types:
  #   content: Content Repos
  #   rest-api: REST API
  types = projects_data['$meta']['types'].each_with_object({}) do |type_info, hash|
    slug = type_info['slug']
    display_text = type_info['text'] || type_info['slug']
    hash[slug] = display_text
  end
  # Write to metadata file
  metadata = {
    'tags' => tags,
    'tech' => tech,
    'types' => types
  }

  File.write('_data/built/projects_metadata.yml', metadata.to_yaml)

  puts 'âœ… Project metadata generated at _data/built/projects_metadata.yml'
end

desc 'Copy the Jekyll-AsciiDoc UI config definition file'
task :copy_jekyll_ui_config do
  pwd = Dir.pwd
  source = '../jekyll-asciidoc-ui/specs/config-def.yml'
  if pwd == '/workspace'
    puts "âš ï¸  Warning: Containerized environment cannot see #{source}; skipping copy."
    next
  end
  dest_dir = '_data/built'
  dest = File.join(dest_dir, 'jekyll-asciidoc-ui-config-def.yml')

  unless File.exist?(source)
    puts "âŒ Source file #{source} does not exist. Please ensure jekyll-asciidoc-ui is cloned."
    exit 1
  end

  FileUtils.mkdir_p(dest_dir)
  FileUtils.cp(source, dest)
  puts "âœ… Copied Jekyll-AsciiDoc UI config definition to #{dest}"
end

desc 'Write RuboCop styles configuration file'
task :write_rubocop_styles do
  FileUtils.mkdir_p('_docs/partials/built')
  build_cmd = 'bundle exec ruby scripts/rubocop_styles_adoc.rb ' \
              'gems/docopslab-dev/assets/config-packs/rubocop/base.yml > ' \
              '_docs/partials/built/_rubocop-styles.adoc'
  system(build_cmd) or raise 'Failed to generate RuboCop styles'
  puts 'âœ… RuboCop styles written to _docs/partials/built/_rubocop-styles.adoc'
end

desc 'Render an AsciiDoc file of universal attributes'
# use _data/docops-lab-projects.yml data and the Liquid template at _includes/docpslab-universal-attributes.asciidoc to produce a file at _docs/partials/built/_docopslab-universal-attributes.adoc
task :generate_universal_attributes do
  puts 'ğŸ“„ Generating universal attributes AsciiDoc file...'

  # Load project data
  projects_data = PROJECTS_DATA

  # Prepare Liquid template
  template_path = '_includes/docopslab-universal-attributes.asciidoc'
  unless File.exist?(template_path)
    puts "âŒ Template file not found: #{template_path}"
    exit 1
  end
  template_content = File.read(template_path)

  # Render Liquid template with project data
  require 'liquid'
  liquid_template = Liquid::Template.parse(template_content)
  rendered_content = liquid_template.render('site' => { 'data' => { 'docops-lab-projects' => projects_data } })

  # Write to destination file
  dest_path = '_docs/partials/built/_docopslab-universal-attributes.adoc'
  FileUtils.mkdir_p(File.dirname(dest_path))
  File.write(dest_path, rendered_content)

  puts "âœ… Generated universal attributes at #{dest_path}"
end

desc 'Build DocOpsLab Vale package for distribution'
task :build_vale_package do
  system('bundle exec ruby scripts/build_vale_package.rb') or raise 'Failed to build Vale package'
end

desc 'Build the Jekyll site (with single-sourced cards and project pages)'
task build_site: %i[extract_readme_attrs generate_project_pages generate_metadata copy_jekyll_ui_config
                    write_rubocop_styles generate_universal_attributes] do
  puts 'ğŸ”¨ Building Jekyll site...'
  system('bundle exec jekyll build') or raise 'Jekyll build failed'
  puts 'âœ… Build complete'
end

desc 'Serve the site locally for development (with single-sourced cards and project pages)'
task serve: [:build_site] do
  port = ENV['PORT'] || '4000'
  puts "ğŸš€ Starting Jekyll development server on port #{port}..."
  serve_cmd = "bundle exec jekyll serve --watch --livereload --port #{port} --skip-initial-build"
  system(serve_cmd) or raise 'Jekyll serve failed'
end

desc 'Clean build artifacts'
task :clean do
  puts 'ğŸ§¹ Cleaning build artifacts...'
  FileUtils.rm_rf(BUILD_DIR)
  FileUtils.rm_rf('.jekyll-cache')
  puts 'âœ… Clean complete'
end

desc 'Update slides from docs-as-code-school repo'
task :update_slides do
  puts 'ğŸ“Š Updating slides from docs-as-code-school...'
  system('./copy-slides.sh') or raise 'Slides update failed'
  puts 'âœ… Slides updated'
end

desc 'Switch to gh-pages branch (for manual inspection)'
task :switch_to_deploy do
  current_branch = `git branch --show-current`.strip

  unless `git status --porcelain`.strip.empty?
    puts 'âŒ You have uncommitted changes. Please commit them first.'
    exit 1
  end

  puts "ğŸ“¦ Switching to #{DEPLOY_BRANCH} branch..."
  system("git checkout #{DEPLOY_BRANCH}") or raise "Failed to checkout #{DEPLOY_BRANCH}"
  puts "âœ… Now on #{DEPLOY_BRANCH} branch. Use 'git checkout #{current_branch}' to return."
end

desc 'Prepare deployment files (SAFE - does not commit or push)'
task prepare_deploy: %i[clean build_site] do
  puts 'ğŸš€ Preparing deployment files...'

  # Save current branch
  current_branch = `git branch --show-current`.strip

  # Check if we have uncommitted changes
  unless `git status --porcelain`.strip.empty?
    puts 'âŒ You have uncommitted changes. Please commit them first.'
    exit 1
  end

  # Store the current commit hash
  `git rev-parse HEAD`.strip

  begin
    # Switch to deploy branch
    puts "ğŸ“¦ Switching to #{DEPLOY_BRANCH} branch..."
    system("git checkout #{DEPLOY_BRANCH}") or raise "Failed to checkout #{DEPLOY_BRANCH}"

    # Clear everything except .git and slides/
    puts 'ğŸ§¹ Clearing deploy branch (preserving slides/)...'
    Dir.glob('*', File::FNM_DOTMATCH).each do |item|
      next if ['.', '..', '.git', SLIDES_DIR].include?(item)

      FileUtils.rm_rf(item)
    end

    # Copy built site contents to root
    puts 'ğŸ“‹ Copying built site to deploy branch...'
    Dir.glob("#{BUILD_DIR}/*", File::FNM_DOTMATCH).each do |item|
      next if ['.', '..'].include?(File.basename(item))

      dest = File.basename(item)
      # Don't overwrite slides/ if it exists in the build
      if dest == SLIDES_DIR && File.exist?(SLIDES_DIR)
        puts "âš ï¸  Preserving existing #{SLIDES_DIR}/ directory"
        next
      end
      FileUtils.cp_r(item, dest)
    end

    # Create a minimal .gitignore for gh-pages branch
    File.write('.gitignore', <<~GITIGNORE)
      # Only ignore truly temporary files in the deploy branch
      .DS_Store
      *.tmp
      *.log
    GITIGNORE

    puts 'âœ… Deployment files prepared!'
    puts "ğŸ“ You are now on the #{DEPLOY_BRANCH} branch."
    puts 'ğŸ” Review the changes with: git status'
    puts 'ğŸ“¦ Commit when ready with: rake commit_deploy'
    puts "ğŸ”„ Return to main branch with: git checkout #{current_branch}"
  rescue StandardError => e
    puts "âŒ Preparation failed: #{e.message}"
    # Always return to original branch on error
    puts "ğŸ”„ Returning to #{current_branch} branch..."
    system("git checkout #{current_branch}")
    exit 1
  end
end

desc 'Commit deployment (run this after prepare_deploy and review)'
task :commit_deploy do
  current_branch = `git branch --show-current`.strip

  unless current_branch == DEPLOY_BRANCH
    puts "âŒ You must be on the #{DEPLOY_BRANCH} branch to commit deployment."
    puts "ï¿½ Run 'rake prepare_deploy' first."
    exit 1
  end

  # Get the main branch commit hash for reference
  main_commit = `git rev-parse main`.strip

  puts 'ï¿½ğŸ’¾ Committing deployment...'
  system('git add -A')
  commit_message = "Deploy from main branch (#{main_commit[0..7]})"

  if system("git commit -m '#{commit_message}'")
    puts 'âœ… Deployment committed!'
    puts 'ğŸŒ Push to origin with: rake push_deploy'
    puts 'ğŸ”„ Return to main branch with: git checkout main'
  else
    puts 'âš ï¸  No changes to commit or commit failed'
  end
end

desc 'Push deployment to origin (DANGER: this updates the live site!)'
task :push_deploy do
  current_branch = `git branch --show-current`.strip

  unless current_branch == DEPLOY_BRANCH
    puts "âŒ You must be on the #{DEPLOY_BRANCH} branch to push deployment."
    puts "ğŸ’¡ Run 'rake prepare_deploy' and 'rake commit_deploy' first."
    exit 1
  end

  puts 'âš ï¸  WARNING: This will update the live site at https://docopslab.org'
  puts 'ğŸ¤” Are you sure you want to continue? (yes/no)'

  response = $stdin.gets.chomp.downcase
  unless %w[yes y].include?(response)
    puts 'âŒ Push cancelled.'
    exit 0
  end

  puts 'ğŸŒ Pushing to origin...'
  if system("git push origin #{DEPLOY_BRANCH}")
    puts 'âœ… Deployment pushed to origin!'
    puts 'ğŸŒ Site updated at: https://docopslab.org'
  else
    puts 'âŒ Push failed!'
    exit 1
  end
end

desc 'Full deployment (prepare + commit + push)'
task deploy: %i[prepare_deploy commit_deploy push_deploy]

desc 'Safe deployment workflow (prepare only - no commit/push)'
task deploy_safe: [:prepare_deploy]

desc 'Deploy with slides update (full workflow)'
task deploy_with_slides: %i[update_slides deploy]

desc 'Safe deploy with slides update (prepare only)'
task deploy_with_slides_safe: %i[update_slides deploy_safe]

desc 'Return to main branch from gh-pages'
task :return_to_main do
  current_branch = `git branch --show-current`.strip
  if current_branch == DEPLOY_BRANCH
    puts 'ğŸ”„ Returning to main branch...'
    system('git checkout main')
    puts 'âœ… Back on main branch'
  else
    puts "â„¹ï¸  Already on #{current_branch} branch"
  end
end

# namespace 'gemdo' for docopslab-dev gem/project related tasks
namespace :gemdo do
  desc 'Build the DocOps Lab Dev Docker image'
  task :build_docker do
    Rake::Task['build_site'].invoke

    # get the image version
    version = DocOpsLab::Dev::VERSION
    puts "ğŸ³ Building DocOps Lab Dev Docker image version #{version}..."
    build_cmd = "VERSION=#{version} ./gems/docopslab-dev/build-docker.sh"
    system(build_cmd) or raise 'Failed to build DocOps Lab Dev Docker image'
    puts 'âœ… Docker image built successfully'
  end

  desc 'Build docopslab-dev gem package to gems/docopslab-dev/pkg/'
  task :build_gem do
    Rake::Task['gemdo:gen_agent_docs'].invoke
    puts 'ğŸ’ Building docopslab-dev gem package...'
    Dir.chdir('gems/docopslab-dev') do
      system('gem build docopslab-dev.gemspec') or raise 'Failed to build docopslab-dev gem'
      FileUtils.mkdir_p('pkg')
      built_gem = Dir.glob('docopslab-dev-*.gem').max_by { |f| File.mtime(f) }
      FileUtils.mv(built_gem, 'pkg/')
      puts "âœ… docopslab-dev gem built at gems/docopslab-dev/pkg/#{File.basename(built_gem)}"
    end
  end

  desc 'Generate agent documentation for docopslab-dev gem'
  task :gen_agent_docs do
    require_relative 'scripts/gen_agent_docs'

    # Ensure Jekyll site is built
    Rake::Task['build_site'].invoke

    # Run the generation script
    GenAgentDocs.run(BUILD_DIR)
  end

  desc 'Test all labdev rake tasks using definitions from tasks-def.yml'
  task :test_tasks, [:filter1, :filter2, :filter3] do |_t, args|
    puts 'ğŸ§ª Running labdev tasks test suite...'

    # Build command with optional filters
    cmd = 'ruby scripts/test_labdev_tasks.rb'

    # Collect all non-nil filter arguments
    filters = [args[:filter1], args[:filter2], args[:filter3]].compact

    cmd += " #{filters.join(' ')}" if filters.any?

    system(cmd) or raise 'Task tests failed'
  end
end
